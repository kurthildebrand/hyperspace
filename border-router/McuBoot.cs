/************************************************************************************************//**
 * @file		McuBoot.cs
 *
 * @copyright	Copyright 2022 Kurt Hildebrand.
 * @license		Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 *				file except in compliance with the License. You may obtain a copy of the License at
 *
 *				http://www.apache.org/licenses/LICENSE-2.0
 *
 *				Unless required by applicable law or agreed to in writing, software distributed under
 *				the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 *				ANY KIND, either express or implied. See the License for the specific language
 *				governing permissions and limitations under the License.
 *
 ***************************************************************************************************/
using System;
using System.Collections.Generic;
using System.IO;

namespace Hyperspace.Firmware
{
	public class McuBoot
	{
		public const UInt32 IMAGE_MAGIC               = 0x96f3b83d;
		public const UInt32 IMAGE_MAGIC_V1            = 0x96f3b83c;
		public const UInt32 IMAGE_MAGIC_NONE          = 0xffffffff;
		public const UInt16 IMAGE_TLV_INFO_MAGIC      = 0x6907;
		public const UInt16 IMAGE_TLV_PROT_INFO_MAGIC = 0x6908;
		public const UInt16 IMAGE_TLV_MAGIC_NONE      = 0xFFFF;

		/* Image header flags */
		public const UInt32 IMAGE_F_PIC               = 0x00000001; /* Not supported. */
		public const UInt32 IMAGE_F_ENCRYPTED         = 0x00000004; /* Encrypted. */
		public const UInt32 IMAGE_F_NON_BOOTABLE      = 0x00000010; /* Split image app. */

		/* Indicates that this image should be loaded into RAM instead of run directly from flash.
		 * The address to load should be in the ih_load_addr field of the header. */
		public const UInt32 IMAGE_F_RAM_LOAD          = 0x00000020;

		/* Indicates that ih_load_addr stores information on flash/ROM address the image has been
		 * built for. */
		public const UInt32 IMAGE_F_ROM_FIXED         = 0x00000100;

		/* ECSDA224 is with NIST P-224
		 * ECSDA256 is with NIST P-256 */

		/* Image trailer TLV types.
		 *
		 * Signature is generated by computing signature over the image hash. Currently the only
		 * image hash type is SHA256.
		 *
		 * Signature comes in the form of 2 TLVs.
		 *   1st on identifies the public key which should be used to verify it.
		 *   2nd one is the actual signature. */
		public const Byte   IMAGE_TLV_KEYHASH     = 0x01; /* hash of the public key */
		public const Byte   IMAGE_TLV_PUBKEY      = 0x02; /* public key */
		public const Byte   IMAGE_TLV_SHA256      = 0x10; /* SHA256 of image hdr and body */
		public const Byte   IMAGE_TLV_RSA2048_PSS = 0x20; /* RSA2048 of hash output */
		public const Byte   IMAGE_TLV_ECDSA224    = 0x21; /* ECDSA of hash output */
		public const Byte   IMAGE_TLV_ECDSA256    = 0x22; /* ECDSA of hash output */
		public const Byte   IMAGE_TLV_RSA3072_PSS = 0x23; /* RSA3072 of hash output */
		public const Byte   IMAGE_TLV_ED25519     = 0x24; /* ed25519 of hash output */
		public const Byte   IMAGE_TLV_ENC_RSA2048 = 0x30; /* Key encrypted with RSA-OAEP-2048 */
		public const Byte   IMAGE_TLV_ENC_KW128   = 0x31; /* Key encrypted with AES-KW-128 */
		public const Byte   IMAGE_TLV_ENC_EC256   = 0x32; /* Key encrypted with ECIES-EC256 */
		public const Byte   IMAGE_TLV_ENC_X25519  = 0x33; /* Key encrypted with ECIES-X25519 */
		public const Byte   IMAGE_TLV_DEPENDENCY  = 0x40; /* Image depends on other image */
		public const Byte   IMAGE_TLV_SEC_CNT     = 0x50; /* security counter */
		public const Byte   IMAGE_TLV_BOOT_RECORD = 0x60; /* measured boot record */

		/* vendor reserved TLVs at xxA0-xxFF, where xx denotes the upper byte range. Examples:
		 *
		 *   0x00a0 - 0x00ff
		 *   0x01a0 - 0x01ff
		 *   0x02a0 - 0x02ff
		 *   ...
		 *   0xffa0 - 0xfffe
		 */
		public const Byte   IMAGE_TLV_VENDOR_MFG_BOARD_FW = 0xA0;

		public class image_version
		{
			public Byte   iv_major;
			public Byte   iv_minor;
			public UInt16 iv_revision;
			public UInt32 iv_build_num;

			public void Parse(BinaryReader reader)
			{
				this.iv_major     = reader.ReadByte();
				this.iv_minor     = reader.ReadByte();
				this.iv_revision  = reader.ReadUInt16();
				this.iv_build_num = reader.ReadUInt32();
			}
		}

		public class image_header
		{
			public UInt32 ih_magic;
			public UInt32 ih_load_addr;
			public UInt16 ih_hdr_size;
			public UInt16 ih_protect_tlv_size;
			public UInt32 ih_img_size;
			public UInt32 ih_flags;
			public image_version ih_ver = new image_version();
			public UInt32 _pad1;

			public bool Parse(BinaryReader reader)
			{
				ih_magic = reader.ReadUInt32();

				if(ih_magic != IMAGE_MAGIC)
				{
					ih_magic = IMAGE_MAGIC_NONE;
					return false;
				}

				ih_load_addr        = reader.ReadUInt32();
				ih_hdr_size         = reader.ReadUInt16();
				ih_protect_tlv_size = reader.ReadUInt16();
				ih_img_size         = reader.ReadUInt32();
				ih_flags            = reader.ReadUInt32();

				ih_ver.Parse(reader);

				_pad1               = reader.ReadUInt32();

				return true;
			}
		}

		public class image_tlv_info
		{
			public UInt16 it_magic = IMAGE_TLV_MAGIC_NONE;
			public UInt16 it_tlv_tot = 0;  /* size of TLV area (including tlv_info header) */
			public long   offset;          /* start of this TLV section */
			public List<image_tlv> tlvs;

			public image_tlv_info()
			{
				tlvs = new List<image_tlv>();
			}

			public bool Parse(BinaryReader reader, image_header header, uint magic)
			{
				if(header.ih_magic == IMAGE_MAGIC_NONE)
				{
					return false;
				}
				else if(magic == IMAGE_TLV_PROT_INFO_MAGIC)
				{
					offset = header.ih_hdr_size + header.ih_img_size;
				}
				else if(magic == IMAGE_TLV_INFO_MAGIC)
				{
					offset = header.ih_hdr_size + header.ih_img_size + header.ih_protect_tlv_size;
				}
				else
				{
					return false;
				}

				reader.BaseStream.Seek(offset, SeekOrigin.Begin);

				it_magic = reader.ReadUInt16();

				if(it_magic != magic)
				{
					return false;
				}

				it_tlv_tot = reader.ReadUInt16();

				while(reader.BaseStream.Position < offset + it_tlv_tot)
				{
					image_tlv tlv = new image_tlv();
					tlv.Parse(reader);
					tlvs.Add(tlv);
				}

				return true;
			}
		}

		public class image_tlv
		{
			public Byte   it_type;   /* IMAGE_TLV_[...]. */
			public Byte   _pad;
			public UInt16 it_len;    /* Data length (not including TLV header). */
			public Byte[] it_data;

			public void Parse(BinaryReader reader)
			{
				it_type = reader.ReadByte();
				_pad    = reader.ReadByte();
				it_len  = reader.ReadUInt16();
				it_data = reader.ReadBytes(it_len);
			}
		}

		public image_header header = new image_header();
		public image_tlv_info prot = new image_tlv_info();
		public image_tlv_info info = new image_tlv_info();
		public string mfg_board_fw = String.Empty;

		public bool Parse(Stream stream)
		{
			using(var reader = new BinaryReader(stream))
			{
				if(!header.Parse(reader))
				{
					return false;
				}

				prot.Parse(reader, header, IMAGE_TLV_PROT_INFO_MAGIC);
				info.Parse(reader, header, IMAGE_TLV_INFO_MAGIC);

				image_tlv mfg_tlv = prot.tlvs.Find(t => t.it_type == IMAGE_TLV_VENDOR_MFG_BOARD_FW);

				if(mfg_tlv != null)
				{
					mfg_board_fw = System.Text.Encoding.UTF8.GetString(mfg_tlv.it_data);
				}

				return true;
			}
		}
	}
}
